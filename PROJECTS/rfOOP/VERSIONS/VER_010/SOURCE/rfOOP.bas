!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: THIS
FUNCTION: LOAD_THIS(SELF)
THIS FUNCTION WILL LOAD (SELF) IN
THE rfoMM STACK MANAGEMENT SYSTEM
!!


FN.DEF LOAD_THIS(SELF)

   BUNDLE.GET 1, "rfoMM", rfoMM
   BUNDLE.GET rfoMM, "rfOOP_STACK", THIS
   BUNDLE.GET rfoMM, "CLASSES", CLASSES
   BUNDLE.GET rfoMM, "OBJECTS", OBJECTS
   
   LIST.SIZE CLASSES, TOTAL_CLASSES
   IF TOTAL_CLASSES > 0
      LIST.SEARCH CLASSES, SELF, EXISTS
   END IF 
   
   IF !EXISTS
      LIST.SIZE OBJECTS, TOTAL_OBJECTS
      IF TOTAL_OBJECTS > 0
         LIST.SEARCH OBJECTS, SELF, EXISTS
      END IF
   END IF 
   
   IF EXISTS
      STACK.ISEMPTY THIS, EXISTS
            
      IF !EXISTS
         STACK.PEEK THIS, CURRENT
         IF CURRENT <> SELF
            STACK.PUSH THIS, SELF
         END IF
      ELSE
         STACK.PUSH THIS, SELF
      END IF
   ELSE
      PRINT "THIS REFERENCE IS NOT LOADED INTO rfOOP MEMORY MANAGEMENT"
      PRINT "...."
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: THIS
FUNCTION: LOAD_THIS(SELF)
THIS FUNCTION LOADS BY (NAME$) TO
THE rfoMM STACK MANAGEMENT SYSTEM
!!


FN.DEF LOAD_THIS$(NAME$)

   BUNDLE.GET 1, "rfoMM", rfoMM
   BUNDLE.GET rfoMM, "rfOOP_STACK", THIS
   BUNDLE.GET rfoMM, "CLASSES", CLASSES
   BUNDLE.GET rfoMM, "OBJECTS", OBJECTS
   
   LIST.SIZE CLASSES, TOTAL_CLASSES
   IF TOTAL_CLASSES > 0
      FOR CLASS = 1 TO TOTAL_CLASSES
         LIST.GET CLASSES, CLASS, CLASS_ID
         BUNDLE.GET CLASS_ID, "NAME", CURRENT_NAME$
         IF CURRENT_NAME$ = NAME$
            THIS_ID = CLASS_ID
            F_N.BREAK
         END IF
      NEXT CLASS
   END IF 
   
   LIST.SIZE OBJECTS, TOTAL_OBJECTS
   IF TOTAL_OBJECTS > 0
      FOR OBJECT = 1 TO TOTAL_OBJECTS
         LIST.GET OBJECTS, OBJECT, OBJECT_ID
         BUNDLE.GET OBJECT_ID, "NAME", CURRENT_NAME$
         IF CURRENT_NAME$ = NAME$
            THIS_ID = OBJECT_ID
            F_N.BREAK
         END IF
      NEXT OBJECT
   END IF 
   
   IF THIS_ID
      STACK.ISEMPTY THIS, EXISTS
            
      IF !EXISTS
         STACK.PEEK THIS, CURRENT
         IF CURRENT <> SELF
            STACK.PUSH THIS, THIS_ID
         END IF
      ELSE
         STACK.PUSH THIS, THIS_ID
      END IF
   ELSE
      PRINT "THE NAME '" + NAME$ + "'IS NOT LOADED INTO rfOOP MEMORY MANAGEMENT"
      PRINT "...."
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: THIS
FUNCTION: THIS()
PEEKS AT THE rfoMM STACK MANAGEMENT SYSTEM AND RETURNS 
THE CURRENT OBJECT OR CLASS / ROOT IS THE rfoMM OBJECT
!!


FN.DEF THIS()

   BUNDLE.GET 1, "rfoMM", rfoMM
   BUNDLE.GET rfoMM, "rfOOP_STACK", THIS
   
   STACK.ISEMPTY THIS, EXISTS
   
   IF !EXISTS
      STACK.PEEK THIS, CURRENT   
      FN.RTN CURRENT
   ELSE
      FN.RTN rfoMM
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: THIS
FUNCTION: THIS_TYPE$()
PEEKS AT THE rfoMM STACK MANAGEMENT SYSTEM AND 
RETURNS THE TYPE OF THE CURRENT OBJECT / CLASS
!!


FN.DEF THIS_TYPE$()

   BUNDLE.GET 1, "rfoMM", rfoMM
   BUNDLE.GET rfoMM, "rfOOP_STACK", THIS
   
   STACK.ISEMPTY THIS, EXISTS
   
   IF !EXISTS
      STACK.PEEK THIS, CURRENT   
      BUNDLE.GET CURRENT, "TYPE", TYPE$
      FN.RTN TYPE$
   ELSE
      FN.RTN "TYPE RETRIEVAL FAILUE: NOTHING LOADED INTO THE rfOOP MEMORY MANAGEMENT STACK"
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: THIS
FUNCTION: THIS_SUBTYPE$()
PEEKS AT THE rfoMM STACK MANAGEMENT SYSTEM AND 
RETURNS SUB TYPE OF THE CURRENT OBJECT / CLASS
!!


FN.DEF THIS_SUBTYPE$()

   BUNDLE.GET 1, "rfoMM", rfoMM
   BUNDLE.GET rfoMM, "rfOOP_STACK", THIS
   
   STACK.ISEMPTY THIS, EXISTS
   
   IF !EXISTS
      STACK.PEEK THIS, CURRENT   
      BUNDLE.GET CURRENT, "SUB TYPE", SUB_TYPE$
      FN.RTN SUB_TYPE$
   ELSE
      FN.RTN "SUB_TYPE RETRIEVAL FAILUE: NOTHING LOADED INTO THE rfOOP MEMORY MANAGEMENT STACK"
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: THIS
FUNCTION: THIS_NAME$()
PEEKS AT THE rfoMM STACK MANAGEMENT SYSTEM AND 
RETURNS THE NAME OF THE CURRENT OBJECT / CLASS
!!


FN.DEF THIS_NAME$()

   BUNDLE.GET 1, "rfoMM", rfoMM
   BUNDLE.GET rfoMM, "rfOOP_STACK", THIS
   
   STACK.ISEMPTY THIS, EXISTS
   
   IF !EXISTS
      STACK.PEEK THIS, CURRENT   
      BUNDLE.GET CURRENT, "NAME", NAME$
      FN.RTN NAME$
   ELSE
      FN.RTN "NAME RETRIEVAL FAILUE: NOTHING LOADED INTO THE rfOOP MEMORY MANAGEMENT STACK"
   END IF 
   
FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: THIS
FUNCTION: THIS_OBJVAR()
PEEK AT THE rfoMM STACK MANAGEMENT SYSTEM AND RETURN
OBJECT VARIABLE BUNDLE OF THE CURRENT OBJECT / CLASS
!!


FN.DEF THIS_OBJVAR()

   BUNDLE.GET 1, "rfoMM", rfoMM
   BUNDLE.GET rfoMM, "rfOOP_STACK", THIS
   
   STACK.ISEMPTY THIS, EXISTS
   
   IF !EXISTS
      STACK.PEEK THIS, CURRENT   
      BUNDLE.GET CURRENT, "OBJECT VARIABLES", OBJECT_VARIABLES
      FN.RTN OBJECT_VARIABLES
   ELSE
      PRINT "OBJECT VARIABLES LIST RETRIEVAL FAILUE: NOTHING LOADED INTO THE rfOOP MEMORY MANAGEMENT STACK"
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: THIS
FUNCTION: THIS_CLASSVAR()
PEEK AT THE rfoMM STACK MANAGEMENT SYSTEM AND RETURN
THE CLASS VARIABLE BUNDLE OF CURRENT OBJECT OR CLASS
!!


FN.DEF THIS_CLASSVAR()

   BUNDLE.GET 1, "rfoMM", rfoMM
   BUNDLE.GET rfoMM, "rfOOP_STACK", THIS
   
   STACK.ISEMPTY THIS, EXISTS
   
   IF !EXISTS
      STACK.PEEK THIS, CURRENT   
      BUNDLE.GET CURRENT, "CLASS VARIABLES", CLASS_VARIABLES
      FN.RTN CLASS_VARIABLES
   ELSE
      PRINT "OBJECT VARIABLES LIST RETRIEVAL FAILUE: NOTHING LOADED INTO THE rfOOP MEMORY MANAGEMENT STACK"
   END IF 

FN.END


FN.DEF GET_THIS(NAME$)

   BUNDLE.GET 1, "rfoMM", rfoMM
   BUNDLE.GET rfoMM, "CLASSES", CLASSES
   
   LIST.SIZE CLASSES, TOTAL_CLASSES
   
   IF TOTAL_CLASSES > 0
      FOR CLASS = 1 TO TOTAL_CLASSES
         LIST.GET CLASSES, CLASS, CLASS_ID
         IF NAME$ = GET_NAME$(CLASS_ID)
            THIS = CLASS_ID
         END IF
      NEXT CLASS
   END IF 
   
   BUNDLE.GET rfoMM, "OBJECTS", OBJECTS
   
   LIST.SIZE OBJECTS, TOTAL_OBJECTS
   
   IF TOTAL_OBJECTS > 0
      FOR OBJECT = 1 TO TOTAL_OBJECTS
         LIST.GET OBJECTS, OBJECT, OBJECT_ID
         IF NAME$ = GET_NAME$(OBJECT_ID)
            THIS = OBJECT_ID
         END IF
      NEXT OBJECT
   END IF 
   
   IF THIS
      FN.RTN THIS
   ELSE
      PRINT "THIS REFERENCE IS NOT LOADED INTO rfOOP MEMORY MANAGEMENT"
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
CLASS: EVENTS
FUNCTION: INIT_EVENTS()
THE EVENT HANDLER CLASS AND OBJECT
CREATED TO rfOOP SPECS USING rfoMM
!!


FN.DEF INIT_EVENTS()
            
   rfOOP_TRIGGERS = MM_CREATE("SL")
   rfOOP_EVENTS   = MM_CREATE("SL")     
   rfOOP_ERRORS   = MM_CREATE("SL") 
   OBJ_VARIABLES  = MM_CREATE("B")
   CLA_VARIABLES  = MM_CREATE("B")
   TYPINGS        = MM_CREATE("B")
    
   EVENTS   = MM_CREATE("C") 
   
   BUNDLE.PUT            TYPINGS,              "INDEX", "P"
   BUNDLE.PUT            TYPINGS,               "NAME", "S"
   BUNDLE.PUT            TYPINGS,               "TYPE", "S"
   BUNDLE.PUT            TYPINGS,           "SUB TYPE", "S"
   BUNDLE.PUT            TYPINGS,            "TYPINGS", "B"
   BUNDLE.PUT            TYPINGS,    "CLASS VARIABLES", "B"
   BUNDLE.PUT            TYPINGS,   "OBJECT VARIABLES", "B"
   BUNDLE.PUT            TYPINGS,       "rfOOP_EVENTS", "SL"  
   BUNDLE.PUT            TYPINGS,     "rfOOP_TRIGGERS", "SL"
   BUNDLE.PUT            TYPINGS,       "rfOOP_ERRORS", "SL"
   
   BUNDLE.PUT             EVENTS,              "INDEX", EVENTS
   BUNDLE.PUT             EVENTS,               "NAME", "EVENT HANDLER"
   BUNDLE.PUT             EVENTS,               "TYPE", "CLASS"
   BUNDLE.PUT             EVENTS,           "SUB TYPE", "EVENT HANDLER"
   BUNDLE.PUT             EVENTS,            "TYPINGS", TYPINGS
   BUNDLE.PUT             EVENTS,    "CLASS VARIABLES", CLA_VARIABLES
   BUNDLE.PUT             EVENTS,   "OBJECT VARIABLES", OBJ_VARIABLES
   BUNDLE.PUT             EVENTS,       "rfOOP_EVENTS", rfOOP_EVENTS  
   BUNDLE.PUT             EVENTS,     "rfOOP_TRIGGERS", rfOOP_TRIGGERS
   BUNDLE.PUT             EVENTS,       "rfOOP_ERRORS", rfOOP_ERRORS   
   
   BUNDLE.GET                  1,              "rfoMM", rfoMM
   BUNDLE.PUT              rfoMM,             "EVENT HANDLER", EVENTS

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: EVENTS
FUNCTION: LOG_EVENT$(IS_ALLOWED$, EVENT$)
USED IN rfOOP FUNCTIONS TO LOG A NEW (EVENT$) IF (IS_ALLOWED$) 
IS SET TO "FAIL" : LOG_ERROR$(EVENT$) & DISPLAY_ERROR$(EVENT$)
!!


FN.DEF LOG_EVENT$(IS_ALLOWED$, EVENT$)

   BUNDLE.GET      1,        "rfoMM", rfoMM
   BUNDLE.GET  rfoMM,       "EVENT HANDLER", EVENTS
   BUNDLE.GET EVENTS, "rfOOP_EVENTS", rfOOP_EVENTS
   
   LIST.ADD rfOOP_EVENTS, EVENT$

   IF IS_ALLOWED$ = "FAIL"
      LOG_ERROR$(EVENT$)
      DISPLAY_ERROR$(EVENT$)
   END IF 
   
FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: EVENTS
FUNCTION: LOG_ERROR$(ERROR_MESSAGE$)
LOG AN (ERROR_MESSAGE$) WHEN USING THE 
rfOOP LIBRARY AND ITS BUILT IN CLASSES
!!


FN.DEF LOG_ERROR$(ERROR_MESSAGE$)

   BUNDLE.GET      1,        "rfoMM", rfoMM
   BUNDLE.GET  rfoMM,       "EVENT HANDLER", EVENTS
   BUNDLE.GET EVENTS, "rfOOP_ERRORS", rfOOP_ERRORS
   
   LIST.ADD rfOOP_ERRORS, ERROR_MESSAGE$

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: EVENTS
FUNCTION: DISPLAY_ERROR$(ERROR_MESSAGE$)
FUNCTION TO DISPLAY AN ERROR WHEN USING 
rfOOP LIBRARY AND ITS BUILT IN CLASSES
!!


FN.DEF DISPLAY_ERROR$(ERROR_MESSAGE$)

   PRINT "rfOOP HAS ENCOUNTERED AN ERROR"
   PRINT ERROR_MESSAGE$
   PRINT "...."

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: EVENTS
FUNCTION: GET_ERRORS()
GET THE ERRORS LIST FROM THE EVENT 
HANDLER AND RETURNS IT TO THE USER
!!


FN.DEF GET_ERRORS()

   BUNDLE.GET      1,        "rfoMM", rfoMM
   BUNDLE.GET  rfoMM,       "EVENT HANDLER", EVENTS
   BUNDLE.GET EVENTS, "rfOOP_ERRORS", rfOOP_ERRORS
   
   FN.RTN rfOOP_ERRORS

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: EVENTS
FUNCTION: ON_EVENT$(TRIGGER$)
USE THIS FUNCTION IN YOUR MAIN LOOP RETURNS 
"TRUE" OR "FALSE" IF THE (TRIGGER$) OCCURS
!!


FN.DEF ON_EVENT$(TRIGGER$)

   BUNDLE.GET      1,          "rfoMM", rfoMM
   BUNDLE.GET  rfoMM,         "EVENT HANDLER", EVENTS
   BUNDLE.GET EVENTS, "rfOOP_TRIGGERS", rfOOP_TRIGGERS

   LIST.SIZE rfOOP_TRIGGERS, TOTAL_TRIGGERS
   
   IF TOTAL_TRIGGERS > 0
      LIST.SEARCH rfOOP_TRIGGERS, TRIGGER$, EXISTS
   END IF 

   IF EXISTS
      LIST.REMOVE rfOOP_TRIGGERS, EXISTS
      FN.RTN "TRUE"
   ELSE
      FN.RTN "FALSE"
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: EVENTS
FUNCTION: CREATE_TRIGGER$(TRIGGER$)
USE THIS FUNCTION TO CREATE A NEW TRIGGER FROM 
(TRIGGER$) FOR USE WITH THE ON_EVENT$(TRIGGER$)
!!


FN.DEF CREATE_TRIGGER$(TRIGGER$)

   BUNDLE.GET      1,          "rfoMM", rfoMM
   BUNDLE.GET  rfoMM,         "EVENT HANDLER", EVENTS
   BUNDLE.GET EVENTS, "rfOOP_TRIGGERS", rfOOP_TRIGGERS

   LIST.ADD rfOOP_TRIGGERS, TRIGGER$

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: EVENTS
FUNCTION: CHECK_EVENT$(EVENT$)
USE THIS FUNCTION TO CHECK FOR (EVENT$)
RETURNS "TRUE" OR "FALSE" IF IT OCCURED
!!


FN.DEF CHECK_EVENT$(EVENT$)

   BUNDLE.GET      1,        "rfoMM", rfoMM
   BUNDLE.GET  rfoMM,       "EVENT HANDLER", EVENTS
   BUNDLE.GET EVENTS, "rfOOP_EVENTS", rfOOP_EVENTS
   
   LIST.SIZE rfOOP_EVENTS, TOTAL_EVENTS
   
   IF TOTAL_EVENTS > 0
      LIST.SEARCH rfOOP_EVENTS, EVENT$, EXISTS
   END IF

   IF EXISTS <> 0
      FN.RTN "TRUE"
   ELSE
      FN.RTN "FALSE"
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: EVENTS
FUNCTION: LAST_EVENT$()
USE THIS FUNCTION TO LOAD THE LAST 
EVENT INTO A {STRING} TYPE VARIABLE
!!


FN.DEF LAST_EVENT$()

   BUNDLE.GET      1,        "rfoMM", rfoMM
   BUNDLE.GET  rfoMM,       "EVENT HANDLER", EVENTS
   BUNDLE.GET EVENTS, "rfOOP_EVENTS", rfOOP_EVENTS

   LIST.SIZE rfOOP_EVENTS, TOTAL_EVENTS
   
   IF TOTAL_EVENTS > 0
      LIST.GET rfOOP_EVENTS, TOTAL_EVENTS, LAST_EVENT$
   END IF 
   
   FN.RTN LAST_EVENT$

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: EVENTS
FUNCTION: GET_EVENTS()
THIS FUNCTION RETURNS THE
EVENT HANDLER EVENTS LIST
!!


FN.DEF GET_EVENTS()

   BUNDLE.GET      1,        "rfoMM", rfoMM
   BUNDLE.GET  rfoMM,       "EVENT HANDLER", EVENTS
   BUNDLE.GET EVENTS, "rfOOP_EVENTS", rfOOP_EVENTS

   FN.RTN rfOOP_EVENTS

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: EVENTS
FUNCTION: CREATE_EVENT(EVENT$)
USE THIS FUNCTION TO CREATE A NEW (EVENT$) CAN BE 
USED TO "ACTIVATE" TRIGGERS OR OTHER EVENT FUNCTIONS
!!


FN.DEF CREATE_EVENT(EVENT$)

   BUNDLE.GET      1,        "rfoMM", rfoMM
   BUNDLE.GET  rfoMM,       "EVENT HANDLER", EVENTS
   BUNDLE.GET EVENTS, "rfOOP_EVENTS", rfOOP_EVENTS

   LIST.ADD rfOOP_EVENTS, EVENT$

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_NAME$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_NAME$(INIT_CLASS, PROPERTY$, TYPINGS)

   BUNDLE.PUT    INIT_CLASS, PROPERTY$, "DEFAULT NAME"
   BUNDLE.PUT    TYPINGS, PROPERTY$, "S"
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS 'DEFAULT NAME'")
   
FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_INDEX$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_INDEX$(INIT_CLASS, PROPERTY$, TYPINGS)

   BUNDLE.PUT    INIT_CLASS, PROPERTY$, INIT_CLASS
   BUNDLE.PUT    TYPINGS, PROPERTY$, "P" 
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS '" + STR$(INIT_CLASS) + "'")
   
FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_TYPE$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_TYPE$(INIT_CLASS, PROPERTY$, TYPINGS)

   BUNDLE.PUT    INIT_CLASS, PROPERTY$, "CLASS"
   BUNDLE.PUT    TYPINGS, PROPERTY$, "S"
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS 'CLASS'")

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_SUBTYPE$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_SUBTYPE$(INIT_CLASS, PROPERTY$, TYPINGS)

   BUNDLE.PUT    INIT_CLASS, PROPERTY$, "SUPER CLASS"
   BUNDLE.PUT    TYPINGS, PROPERTY$, "S"
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS 'SUPER CLASS'")
   
FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_TYPINGS$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_TYPINGS$(INIT_CLASS, PROPERTY$, TYPINGS)

   BUNDLE.PUT    INIT_CLASS, PROPERTY$, TYPINGS
   BUNDLE.PUT    TYPINGS, PROPERTY$, "B"
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS 'TYPINGS'")
   
FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_CLAVAR$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_CLAVAR$(INIT_CLASS, PROPERTY$, TYPINGS)

   CLASS_VARIABLES = MM_CREATE("B")
   BUNDLE.PUT    CLASS_VARIABLES, "CLASS NAME", "DEFAULT NAME"
   BUNDLE.PUT    INIT_CLASS, PROPERTY$, CLASS_VARIABLES
   BUNDLE.PUT    TYPINGS, PROPERTY$, "B" 
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS '" + STR$(CLASS_VARIABLES) + "'")

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_OBJVAR$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_OBJVAR$(INIT_CLASS, PROPERTY$, TYPINGS)

   BUNDLE.PUT    INIT_CLASS, PROPERTY$, DEFAULT_VALUE
   BUNDLE.PUT    TYPINGS, PROPERTY$, "B" 
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS '" + STR$(CLASS_VARIABLES) + "'")

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_STRING$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_STRING$(INIT_CLASS, PROPERTY$, TYPINGS)

   BUNDLE.PUT    INIT_CLASS, PROPERTY$, "DEFAULT VALUE"
   BUNDLE.PUT    TYPINGS, PROPERTY$, "S"
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS STRING")

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_NUMERIC$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_NUMERIC$(INIT_CLASS, PROPERTY$, TYPINGS)

   BUNDLE.PUT    INIT_CLASS, PROPERTY$, 0
   BUNDLE.PUT    TYPINGS, PROPERTY$, "N"
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS NUMERIC")

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_STRINGL$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_STRINGL$(INIT_CLASS, PROPERTY$, TYPINGS)

   SPECIAL_TYPE = = MM_CREATE("SL")
   BUNDLE.PUT    INIT_CLASS, PROPERTY$, SPECIAL_TYPE
   BUNDLE.PUT    TYPINGS, PROPERTY$, "SL"
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS STRING LIST")

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_NUMERICL$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_NUMERICL$(INIT_CLASS, PROPERTY$, TYPINGS)

   SPECIAL_TYPE = MM_CREATE("NL")
   BUNDLE.PUT    INIT_CLASS, PROPERTY$, SPECIAL_TYPE
   BUNDLE.PUT    TYPINGS, PROPERTY$, "NL"
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS NUMERIC LIST")

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_B$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_B$(INIT_CLASS, PROPERTY$, TYPINGS)

   SPECIAL_TYPE = MM_CREATE("B")
   BUNDLE.PUT    INIT_CLASS, PROPERTY$, SPECIAL_TYPE
   BUNDLE.PUT    TYPINGS, PROPERTY$, "B"
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS BUNDLE")

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS_P$(INIT_CLASS, PROPERTY$, TYPINGS)
HELPER FUNCTION FOR INIT_CLASS(SELF)
TO ENSURE READABILITY AND MODULARITY
!!


FN.DEF INIT_CLASS_P$(INIT_CLASS, PROPERTY$, TYPINGS)

!  SPECIAL_TYPE = MM_CREATE("B")
   BUNDLE.PUT    INIT_CLASS, PROPERTY$, SPECIAL_TYPE
   BUNDLE.PUT    TYPINGS, PROPERTY$, "P"
   LOG_EVENT$("PASS", "INIT PROPERTY SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "' PROPERTY '" + PROPERTY$ + "' AS POINTER") 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: INIT_CLASS
FUNCTION: INIT_CLASS(CLASS)
INITIALIZE CLASS FROM CREATE_CLASS() OR FROM
DEFINED FUNCTION WITH APPROPRIATE PROPERTIES
!!


FN.DEF INIT_CLASS(CLASS)

   IF MM_VALIDATE$(CLASS) = "FAIL"
      LOG_EVENT$("FAIL", "rfOOP VALIDATION ERROR: THE REFERENCED POINTER '" + STR$(INIT_CLASS) + "' IS NOT PROPERLY DEFINED IN THE rfOOP MEMORY SPACE")
   ELSE   
      TYPINGS    = MM_CREATE("B")  
      INIT_CLASS = MM_CREATE("C")

      PROPERTIES = MM_KEYS(CLASS)

      LIST.SIZE PROPERTIES, TOTAL_PROPERTIES

      FOR PROPERTY = 1 TO TOTAL_PROPERTIES
         LIST.GET PROPERTIES, PROPERTY, PROPERTY$
         BUNDLE.GET CLASS, PROPERTY$, PROPERTY_TYPE$
      
         IF PROPERTY$ = "NAME"        
            INIT_CLASS_NAME$(INIT_CLASS, PROPERTY$, TYPINGS)
         ELSEIF PROPERTY$ = "INDEX"
            INIT_CLASS_INDEX$(INIT_CLASS, PROPERTY$, TYPINGS)
         ELSEIF PROPERTY$ = "TYPE"
            INIT_CLASS_TYPE$(INIT_CLASS, PROPERTY$, TYPINGS)
         ELSEIF PROPERTY$ = "SUB TYPE"
            INIT_CLASS_SUBTYPE$(INIT_CLASS, PROPERTY$, TYPINGS)
         ELSEIF PROPERTY$ = "TYPINGS"         
            INIT_CLASS_TYPINGS$(INIT_CLASS, PROPERTY$, TYPINGS)
         ELSEIF PROPERTY$ = "CLASS VARIABLES"         
            INIT_CLASS_CLAVAR$(INIT_CLASS, PROPERTY$, TYPINGS)
         ELSEIF PROPERTY$ = "OBJECT VARIABLES"         
            INIT_CLASS_OBJVAR$(INIT_CLASS, PROPERTY$, TYPINGS)
         ELSE
            IF PROPERTY_TYPE$ = "S"
               INIT_CLASS_STRING$(INIT_CLASS, PROPERTY$, TYPINGS)
            ELSEIF PROPERTY_TYPE$ = "N"
               INIT_CLASS_NUMERIC$(INIT_CLASS, PROPERTY$, TYPINGS)
            ELSEIF PROPERTY_TYPE$ = "SL"
               INIT_CLASS_STRINGL$(INIT_CLASS, PROPERTY$, TYPINGS)
            ELSEIF PROPERTY_TYPE$ = "NL"
               INIT_CLASS_NUMERICL$(INIT_CLASS, PROPERTY$, TYPINGS)
            ELSEIF PROPERTY_TYPE$ = "B"
               INIT_CLASS_B$(INIT_CLASS, PROPERTY$, TYPINGS)
            ELSEIF PROPERTY_TYPE$ = "P"
               INIT_CLASS_P$(INIT_CLASS, PROPERTY$, TYPINGS)
            END IF
         END IF 
      NEXT PROPERTY
      
      MM_DELETE(PROPERTIES, "SL")       
                
      LOG_EVENT$("PASS", "INIT CLASS SUCCESS: SUCCESSFULLY INITIALIZED CLASS '" + STR$(INIT_CLASS) + "'")
      LOAD_THIS(INIT_CLASS)
      FN.RTN INIT_CLASS
   END IF
                     
FN.END

!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: rfOOP_CLASSES
FUNCTION: CREATE_CLASS()
CREATE A NEW CLASS AND LOAD REQUIRED PROPERTIES 
AUTOMATICALLY RETURNS THE INIT_CLASS() FUNCTION 
!!


FN.DEF CREATE_CLASS()

   NEW_CLASS = MM_CREATE("B")
   
   BUNDLE.PUT    NEW_CLASS, "NAME", "S"
   BUNDLE.PUT    NEW_CLASS, "INDEX", "N"
   BUNDLE.PUT    NEW_CLASS, "TYPE", "S"
   BUNDLE.PUT    NEW_CLASS, "SUB TYPE", "S"
   BUNDLE.PUT    NEW_CLASS, "TYPINGS", "N"
   BUNDLE.PUT    NEW_CLASS, "CLASS VARIABLES", "N"
   BUNDLE.PUT    NEW_CLASS, "OBJECT VARIABLES", "N"
   
   LOG_EVENT$("PASS", "CLASS CREATION SUCCESS: SUCCESSFULLY CREATED A NEW CLASS")
   
   FN.RTN INIT_CLASS(NEW_CLASS)

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: rfOOP_CLASSES
FUNCTION: GET_NAME$(SELF)
GET THE NAME PROPERTY FOR (SELF)
PASS rfOOP OBJECT OR rfOOP CLASS
!!


FN.DEF GET_NAME$(SELF)

   IF MM_VALIDATE$(SELF) = "PASS"
      BUNDLE.GET SELF, "NAME", NAME$
      LOG_EVENT$("PASS", "NAME RETRIEVAL SUCCESS: SUCCESSFULLY RETRIEVED PROPERTY DEFINED AS 'NAME' OF '" + STR$(SELF) + "'")
      LOAD_THIS(SELF)
      FN.RTN NAME$
   ELSE
      LOG_EVENT$("FAIL", "NAME RETRIEVAL FAILURE: FAILED TO RETRIEVE NAME OF POINTER REFERENCED AT '" + STR$(SELF) + "' AS IT HAS NOT BEEN DEFINED PROPERLY AS AN rfOOP OBJECT OR CLASS")
   END IF

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: rfOOP_CLASSES
FUNCTION: SET_NAME$(SELF, NEW_NAME$)
SET PROPERTY OF (SELF) FOR rfOOP OBJECT OR 
rfOOP CLASS DEFINED AS NAME TO (NEW_NAME$)  
!!


FN.DEF SET_NAME$(SELF, NEW_NAME$)

   IF MM_VALIDATE$(SELF) = "PASS"
      BUNDLE.GET SELF, "NAME", OLD_NAME$
      BUNDLE.PUT SELF, "NAME", NEW_NAME$
      
      LOG_EVENT$("PASS", "NAME CHANGE SUCCESS: SUCCESSFULLY RENAMED '" + OLD_NAME$ + "'" + "TO '" + NEW_NAME$ + "'")
      LOAD_THIS(SELF)
   ELSE
      LOG_EVENT$("FAIL", "NAME CHANGE FAILURE: FAILED TO CHANGE NAME OF POINTER REFERENCED AT '" + STR$(SELF) + "' AS IT HAS NOT BEEN DEFINED PROPERLY AS AN rfOOP OBJECT OR CLASS")
   END IF
        
   BUNDLE.GET SELF, "TYPE", TYPE$
   
   IF IS_IN("CLASS", TYPE$)
      BUNDLE.GET SELF, "CLASS VARIABLES", CLAVAR
      BUNDLE.PUT CLAVAR, "CLASS NAME", NEW_NAME$
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: rfOOP_CLASSES
FUNCTION: ADD_PROPERTY$(CLASS, PROPERTY$, TYPE$)
ADD PROPERTY (PROPERTY$) AS STRING TO AN rfOOP 
CLASS: CURRENTLY SUPPORTS (TYPE$) "S" AND "SL"
!!


FN.DEF ADD_PROPERTY$(CLASS, PROPERTY$, TYPE$)

   IF MM_VALIDATE$(CLASS) = "PASS"
      IF TYPE$ = "S"
         BUNDLE.PUT CLASS, PROPERTY$, "DEFAULT VALUE"
         LOG_EVENT$("PASS", "PROPERTY ADDITION SUCCESS: NEW PROPERTY '" + PROPERTY$ + "' OF 'STRING' TYPE HAS BEEN ADDED TO CLASS '" + GET_NAME$(CLASS) + "'") 
      ELSEIF TYPE$ = "SL"
         BUNDLE.PUT CLASS, PROPERTY$, DEFAULT_VALUE
         LOG_EVENT$("PASS", "PROPERTY ADDITION SUCCESS: NEW PROPERTY '" + PROPERTY$ + "' OF 'STRING LIST' TYPE HAS BEEN ADDED TO CLASS '" + GET_NAME$(CLASS) + "'")
      ELSE
         LOG_EVENT$("FAIL", "PROPERTY ADDITION FAILURE: ERROR ADDING PROPERTY: '" + PROPERTY$ + "' DUE TO TYPE MISMATCH, PLEASE SPECIFY 'S' OR 'SL' FOR TYPE AS STRING OR USE ADD_PROPERTY() INSTEAD FOR NUMERIC TYPE")
      END IF
   ELSE
      LOG_EVENT$("FAIL", "PROPERTY ADDITION FAILURE: THE PROPERTY NAMED '" + PROPERTY$ + "'ALREADY EXISTS")
   END IF
   
   BUNDLE.GET CLASS, "TYPINGS", TYPINGS
   BUNDLE.PUT TYPINGS, PROPERTY$, TYPE$
   LOAD_THIS(CLASS)

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: rfOOP_CLASSES
FUNCTION: ADD_PROPERTY(CLASS, PROPERTY$, TYPE$)
ADD A PROPERTY (PROPERTY$) AS NUMERIC TYPE TO AN rfOOP 
CLASS: CURRENTLY SUPPORTS (TYPE$) "N" "NL" "B" AND "P"
!!


FN.DEF ADD_PROPERTY(CLASS, PROPERTY$, TYPE$)

   IF MM_VALIDATE$(CLASS) = "PASS"
      IF TYPE$ = "N"
         BUNDLE.PUT CLASS, PROPERTY$, DEFAULT_VALUE
         LOG_EVENT$("PASS", "PROPERTY ADDITION SUCCESS: NEW PROPERTY '" + PROPERTY$ + "' OF '" + TYPE$ + "' TYPE HAS BEEN ADDED TO CLASS '" + GET_NAME$(CLASS) + "'")
      ELSEIF TYPE$ = "NL"         
         BUNDLE.PUT CLASS, PROPERTY$, DEFAULT_VALUE
         LOG_EVENT$("PASS", "PROPERTY ADDITION SUCCESS: NEW PROPERTY '" + PROPERTY$ + "' OF '" + TYPE$ + "' TYPE HAS BEEN ADDED TO CLASS '" + GET_NAME$(CLASS) + "'")
      ELSEIF TYPE$ = "B"
         BUNDLE.PUT CLASS, PROPERTY$, DEFAULT_VALUE
         LOG_EVENT$("PASS", "PROPERTY ADDITION SUCCESS: NEW PROPERTY '" + PROPERTY$ + "' OF '" + TYPE$ + "' TYPE HAS BEEN ADDED TO CLASS '" + GET_NAME$(CLASS) + "'")
      ELSEIF TYPE$ = "P"
         BUNDLE.PUT CLASS, PROPERTY$, DEFAULT_VALUE
         LOG_EVENT$("PASS", "PROPERTY ADDITION SUCCESS: NEW PROPERTY '" + PROPERTY$ + "' OF '" + TYPE$ + "' TYPE HAS BEEN ADDED TO CLASS '" + GET_NAME$(CLASS) + "'")
      ELSE
         LOG_EVENT$("FAIL", "PROPERTY ADDITION FAILURE: ERROR ADDING PROPERTY: '" + PROPERTY$ + "' DUE TO TYPE MISMATCH, PLEASE SPECIFY 'N' 'NL' 'B' OR 'P' FOR TYPE AS NUMERIC OR USE ADD_PROPERTY$() INSTEAD FOR STRING TYPE")
      END IF
   ELSE
      LOG_EVENT$("PASS", "PROPERTY ADDITION FAILURE: THE PROPERTY NAMED '" + PROPERTY$ + "'ALREADY EXISTS")
   END IF 
   
   BUNDLE.GET CLASS, "TYPINGS", TYPINGS
   BUNDLE.PUT TYPINGS, PROPERTY$, TYPE$
   LOAD_THIS(CLASS)

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: OBJECTS_AND_CLASSES
FUNCTION: CREATE_OBJECT(CLASS)
CREATE A NEW OBJECT FROM (CLASS)
RETURN THE NEW OBJECT TO THE USER 
!!


FN.DEF CREATE_OBJECT(CLASS)

   IF MM_VALIDATE$(CLASS) = "PASS"
      NEW_OBJECT = MM_CREATE("O")
      OBJECT_KEYS = MM_KEYS(CLASS)

      LIST.SIZE OBJECT_KEYS, TOTAL_PROPERTIES

      FOR PROPERTY = 1 TO TOTAL_PROPERTIES
         LIST.GET OBJECT_KEYS, PROPERTY, CURRENT_PROPERTY$
         BUNDLE.TYPE CLASS, CURRENT_PROPERTY$, PROPERTY_TYPE$
         IF CURRENT_PROPERTY$ = "NAME"
            BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, "DEFAULT NAME"         
            LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS 'DEFAULT NAME'")
         ELSEIF CURRENT_PROPERTY$ = "INDEX"
            BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, NEW_OBJECT
            LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS '" + STR$(NEW_OBJECT) + "'")
         ELSEIF CURRENT_PROPERTY$ = "TYPE"
            BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, "OBJECT" 
            LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS 'OBJECT'")
         ELSEIF CURRENT_PROPERTY$ = "SUB TYPE"
            BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, "OG_OBJECT"
            LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS 'OG_OBJECT'")
         ELSEIF CURRENT_PROPERTY$ = "TYPINGS"
            OBJECT_SPECIAL_TYPINGS = MM_CREATE("B")    
            BUNDLE.GET    CLASS, CURRENT_PROPERTY$, SPECIAL_TYPINGS
            BUNDLE.KEYS SPECIAL_TYPINGS, SPECIAL_TYPING_KEYS 
            LIST.SIZE SPECIAL_TYPING_KEYS, TOTAL_SPECIAL_TYPES     
            FOR TYPING = 1 TO TOTAL_SPECIAL_TYPES
               LIST.GET SPECIAL_TYPING_KEYS, TYPING, SPECIAL_TYPE$
               BUNDLE.GET    SPECIAL_TYPINGS, SPECIAL_TYPE$, SPECIAL_TYPING$            
               BUNDLE.PUT    OBJECT_SPECIAL_TYPINGS, SPECIAL_TYPE$, SPECIAL_TYPING$ 
            NEXT TYPING
            BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, OBJECT_SPECIAL_TYPINGS
            LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS 'TYPINGS'")
         ELSEIF CURRENT_PROPERTY$ = "CLASS VARIABLES"
            BUNDLE.GET    CLASS, CURRENT_PROPERTY$, CLASS_VARIABLES
            BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, CLASS_VARIABLES
            LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS '" + STR$(CLASS_VARIABLES) + "'")
         ELSEIF CURRENT_PROPERTY$ = "OBJECT VARIABLES"
            OBJECT_VARIABLES = MM_CREATE("B")
            BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, OBJECT_VARIABLES
            LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS '" + STR$(OBJECT_VARIABLES) + "'")
         ELSE
            IF PROPERTY_TYPE$ = "S"
               BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, "DEFAULT VALUE"
               LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS STRING TYPE")
            ELSEIF PROPERTY_TYPE$ = "SL"
               SPECIAL_TYPE_SL = MM_CREATE("SL")
               BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, SPECIAL_TYPE_SL
               LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS STRING TYPE")         
            ELSEIF PROPERTY_TYPE$ = "N"
               BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, DEFAULT_VALUE
               LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS NUMERIC TYPE")
            ELSEIF PROPERTY_TYPE$ = "NL"
               SPECIAL_TYPE_NL = MM_CREATE("NL")
               BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, SPECIAL_TYPE_NL
               LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS NUMERIC LIST TYPE")
            ELSEIF PROPERTY_TYPE$ = "B"
               SPECIAL_TYPE_B = MM_CREATE("B")
               BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, SPECIAL_TYPE_B
               LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS NUMERIC BUNDLE TYPE")
            ELSEIF PROPERTY_TYPE$ = "P"
               BUNDLE.PUT    NEW_OBJECT, CURRENT_PROPERTY$, DEFAULT_VALUE
               LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED OBJECT '" + STR$(NEW_OBJECT) + "' PROPERTY '" + CURRENT_PROPERTY$ + "' AS NUMERIC POINTER TYPE")
            END IF         
         ENDIF
      NEXT PROPERTY
      
      MM_DELETE(OBJECT_KEYS, "SL")
      
      LOG_EVENT$("PASS", "SUCCESSFULLY INITIALIZED CLASS '" + STR$(NEW_OBJECT) + "'")
      LOAD_THIS(NEW_OBJECT)
      FN.RTN NEW_OBJECT 
   ELSE
      LOG_EVENT$("FAIL", "rfOOP VALIDATION ERROR: THE REFERENCED POINTER '" + STR$(INIT_CLASS) + "' IS NOT PROPERLY DEFINED IN THE rfOOP MEMORY SPACE")
   END IF              

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: OBJECTS_AND_CLASSES
FUNCTION: MODIFY_ATTRIBUTE$(OBJECT, PROPERTY$, ATTRIBUTE$)
SET ATTRIBUTE OF PROPERTY NAMED (PROPERTY$) 
OF (OBJECT) TO (ATTRIBUTE$) AS {STRING} TYPE
!!


FN.DEF MODIFY_ATTRIBUTE$(OBJECT, PROPERTY$, ATTRIBUTE$)

   IF MM_VALIDATE$(OBJECT) = "PASS"
      OBJECT_KEYS = MM_KEYS(OBJECT)

      BUNDLE.GET OBJECT, "TYPE", TYPE$

      IF TYPE$ <> "CLASS"
         LIST.SEARCH OBJECT_KEYS, PROPERTY$, EXISTS
         IF EXISTS <> 0
            BUNDLE.PUT OBJECT, PROPERTY$, ATTRIBUTE$
            LOG_EVENT$("PASS", "SUCCESSFULLY MODIFIED THE 'STRING' TYPE ATTRIBUTE OF '" + GET_NAME$(OBJECT) + "' DEFINED AS PROPERTY '" + PROPERTY$ + "' TO '" + ATTRIBUTE$ + "'")
            LOAD_THIS(OBJECT)
            MM_DELETE(OBJECT_KEYS, "SL")
         ELSE
            LOG_EVENT$("FAIL", "CAN NOT MODIFY 'STRING' TYPE PROPERTY DEFINED AS '" + PROPERTY$ + "' OF '" + GET_NAME$(OBJECT) + "' AS IT DOES NOT EXIST")
         END IF
      ELSE
         LOG_EVENT$("FAIL", "YOU ARE ATTEMPTING TO MODIFY THE TYPE OF A CLASS INSTEAD OF THE ATTRIBUTE OF AN OBJECT")
      ENDIF
   ELSE
      LOG_EVENT$("FAIL", "rfOOP VALIDATION ERROR: THE REFERENCED POINTER '" + STR$(INIT_CLASS) + "' IS NOT PROPERLY DEFINED IN THE rfOOP MEMORY SPACE")
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: OBJECTS_AND_CLASSES
FUNCTION: MODIFY_ATTRIBUTE(OBJECT, PROPERTY$, ATTRIBUTE)
SET ATTRIBUTE OF PROPERTY NAMED (PROPERTY$) 
OF (OBJECT) TO (ATTRIBUTE) AS {NUMBER} TYPE
!!


FN.DEF MODIFY_ATTRIBUTE(OBJECT, PROPERTY$, ATTRIBUTE)

   IF MM_VALIDATE$(OBJECT) = "PASS"
      OBJECT_KEYS = MM_KEYS(OBJECT)

      BUNDLE.GET OBJECT, "TYPE", TYPE$

      IF TYPE$ <> "CLASS"
         LIST.SEARCH OBJECT_KEYS, PROPERTY$, EXISTS
         IF EXISTS <> 0
            BUNDLE.PUT OBJECT, PROPERTY$, ATTRIBUTE
            LOG_EVENT$("PASS", "SUCCESSFULLY MODIFIED THE 'NUMERIC' TYPE ATTRIBUTE OF '" + GET_NAME$(OBJECT) + "' DEFINED AS PROPERTY '" + PROPERTY$ + "' TO '" + STR$(ATTRIBUTE) + "'")
            LOAD_THIS(OBJECT)
            MM_DELETE(OBJECT_KEYS, "SL")
         ELSE
            LOG_EVENT$("FAIL", "CAN NOT MODIFY 'NUMERIC' TYPE PROPERTY DEFINED AS '" + PROPERTY$ + "' OF '" + GET_NAME$(OBJECT) + "' AS IT DOES NOT EXIST")
         END IF
      ELSE
         LOG_EVENT$("FAIL", "YOU ARE ATTEMPTING TO MODIFY THE TYPE OF A CLASS INSTEAD OF THE ATTRIBUTE OF AN OBJECT")
      ENDIF
   ELSE
      LOG_EVENT$("FAIL", "rfOOP VALIDATION ERROR: THE REFERENCED POINTER '" + STR$(INIT_CLASS) + "' IS NOT PROPERLY DEFINED IN THE rfOOP MEMORY SPACE")
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: OBJECTS_AND_CLASSES
FUNCTION: GET_ATTRIBUTE$(OBJECT, PROPERTY$)
GET ATTRIBUTE OF PROPERTY NAMED (PROPERTY$) 
OF (OBJECT) TO (ATTRIBUTE$) AS {STRING} TYPE
!!


FN.DEF GET_ATTRIBUTE$(OBJECT, PROPERTY$)

   IF MM_VALIDATE$(OBJECT) = "PASS"
      KEYS = MM_KEYS(OBJECT)

      LIST.SEARCH KEYS, PROPERTY$, EXISTS

      IF EXISTS <> 0 
         BUNDLE.TYPE OBJECT, PROPERTY$, TYPE$
         IF TYPE$ = "S"
            BUNDLE.GET OBJECT, PROPERTY$, ATTRIBUTE$
            LOG_EVENT$("PASS", "SUCCESSFULLY RETRIEVED 'STRING' TYPE ATTRIBUTE DEFINED AS '" + ATTRIBUTE$ + "' FROM PROPERTY '" + PROPERTY$ + "'") 
            LOAD_THIS(OBJECT)
            MM_DELETE(KEYS, "SL")
         ELSE IF TYPE$ = "N"
            BUNDLE.GET OBJECT, PROPERTY$, ATTRIBUTE
            ATTRIBUTE$ = STR$(ATTRIBUTE)
            LOG_EVENT$("PASS", "SUCCESSFULLY RETRIEVED 'NUMERIC' TYPE ATTRIBUTE DEFINED AS '" + ATTRIBUTE$ + "' FROM PROPERTY '" + PROPERTY$ + "' AS A 'STRING' TYPE")  
            LOAD_THIS(OBJECT)             
         END IF
      ELSE
         LOG_EVENT$("FAIL", "FAILED TO RETRIEVE PROPERTY '" + PROPERTY$ + "' AS IT DOES NOT EXIST")
      END IF
   
      FN.RTN ATTRIBUTE$
   ELSE
      LOG_EVENT$("FAIL", "rfOOP VALIDATION ERROR: THE REFERENCED POINTER '" + STR$(INIT_CLASS) + "' IS NOT PROPERLY DEFINED IN THE rfOOP MEMORY SPACE")
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: OBJECTS_AND_CLASSES
FUNCTION: GET_ATTRIBUTE(OBJECT, PROPERTY$)
GET ATTRIBUTE OF PROPERTY NAMED (PROPERTY$) 
OF (OBJECT) TO (ATTRIBUTE$) AS {NUMBER} TYPE
!!


FN.DEF GET_ATTRIBUTE(OBJECT, PROPERTY$)

   IF MM_VALIDATE$(OBJECT) = "PASS"
      KEYS = MM_KEYS(OBJECT)

      LIST.SEARCH KEYS, PROPERTY$, EXISTS

      IF EXISTS <> 0
         BUNDLE.TYPE OBJECT, PROPERTY$, TYPE$
         IF TYPE$ = "S"
            LOG_EVENT$("FAIL", "CAN NOT GET THE ATTRIBUTE AT THE PROPERTY NAMED '" + PROPERTY$ + "' DUE TO TYPE MISMATCH, EXPECTING 'N'")
         ELSE IF TYPE$ = "N"
            BUNDLE.GET OBJECT, PROPERTY$, ATTRIBUTE
            LOG_EVENT$("PASS", "SUCCESSFULLY RETRIEVED 'NUMERIC' TYPE ATTRIBUTE DEFINED AS '" + STR$(ATTRIBUTE) + "' FROM PROPERTY '" + PROPERTY$ + "'")
            LOAD_THIS(OBJECT)
            MM_DELETE(KEYS, "SL")
         END IF
      ELSE
      LOG_EVENT$("FAIL", "FAILED TO RETRIEVE PROPERTY '" + PROPERTY$ + "' AS IT DOES NOT EXIST")
      END IF 

      FN.RTN ATTRIBUTE
   ELSE
      LOG_EVENT$("FAIL", "rfOOP VALIDATION ERROR: THE REFERENCED POINTER '" + STR$(INIT_CLASS) + "' IS NOT PROPERLY DEFINED IN THE rfOOP MEMORY SPACE")
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: VARIABLES
FUNCTION: GET_VARIABLE$(SELF, VAR_NAME$)
GET A (VAR_NAME$) AS {STRING} TYPE FROM 
OBJECT OR CLASS VARIABLE LIST OF (SELF)
!!


FN.DEF SEARCH_CLAVAR(SELF, VAR_NAME$)

   BUNDLE.GET SELF, "CLASS VARIABLES", CLAVAR                  
   BUNDLE.KEYS CLAVAR, CLAVAR_KEYS
      
   LIST.SIZE CLAVAR_KEYS, TOTAL_CLAKEYS
      
   IF TOTAL_CLAKEYS > 0 
      LIST.SEARCH CLAVAR_KEYS, VAR_NAME$, CLAVAR_EXISTS
   END IF
   
   FN.RTN CLAVAR_EXISTS

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: VARIABLES
FUNCTION: GET_VARIABLE$(SELF, VAR_NAME$)
GET A (VAR_NAME$) AS {STRING} TYPE FROM 
OBJECT OR CLASS VARIABLE LIST OF (SELF)
!!


FN.DEF SEARCH_OBJVAR(SELF, VAR_NAME$)

   BUNDLE.GET SELF, "OBJECT VARIABLES", OBJVAR                  
   BUNDLE.KEYS OBJVAR, OBJVAR_KEYS
      
   LIST.SIZE OBJVAR_KEYS, TOTAL_OBJKEYS
      
   IF TOTAL_OBJKEYS > 0 
      LIST.SEARCH OBJVAR_KEYS, VAR_NAME$, OBJVAR_EXISTS
   END IF
   
   FN.RTN OBJVAR_EXISTS

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: VARIABLES
FUNCTION: GET_VARIABLE$(SELF, VAR_NAME$)
GET A (VAR_NAME$) AS {STRING} TYPE FROM 
OBJECT OR CLASS VARIABLE LIST OF (SELF)
!!


FN.DEF EXISTS_BOTH_VARS(OBJVAR_EXISTS, CLAVAR_EXISTS)

   IF OBJVAR_EXISTS
      IF CLAVAR_EXISTS
         LOG_EVENT$("FAIL", "VARIABLE RETRIEVAL FAILURE: VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS BOTH CLASS AND OBJECT")
      END IF
   END IF 
      
FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: VARIABLES
FUNCTION: GET_VARIABLE$(SELF, VAR_NAME$)
GET A (VAR_NAME$) AS {STRING} TYPE FROM 
OBJECT OR CLASS VARIABLE LIST OF (SELF)
!!


FN.DEF EXISTS_NEITHER_VARS(OBJVAR_EXISTS, CLAVAR_EXISTS)

   IF !OBJVAR_EXISTS
      IF !CLAVAR_EXISTS
         LOG_EVENT$("FAIL", "VARIABLE RETRIEVAL FAILURE: NO VARIABLE NAMED '" + VAR_NAME$ + "' FOUND IN OBJECT OR CLASS SPACE")
      END IF
   END IF

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: VARIABLES
FUNCTION: GET_VARIABLE$(SELF, VAR_NAME$)
GET A (VAR_NAME$) AS {STRING} TYPE FROM 
OBJECT OR CLASS VARIABLE LIST OF (SELF)
!!

FN.DEF GET_VARIABLE$(SELF, VAR_NAME$)

   IF MM_VALIDATE$(SELF) = "PASS"
   
      LOAD_THIS(SELF)
       
      CLAVAR_EXISTS = SEARCH_CLAVAR(SELF, VAR_NAME$)
      OBJVAR_EXISTS = SEARCH_OBJVAR(SELF, VAR_NAME$)
      
      EXISTS_BOTH_VARS(OBJVAR_EXISTS, CLAVAR_EXISTS)
      EXISTS_NEITHER_VARS(OBJVAR_EXISTS, CLAVAR_EXISTS)
      
      IF CLAVAR_EXISTS
         IF !OBJVAR_EXISTS
            BUNDLE.GET SELF, "CLASS VARIABLES", CLAVAR
            BUNDLE.GET CLAVAR, VAR_NAME$, RESPONSE$
            FN.RTN RESPONSE$
         END IF
      END IF
      
      IF OBJVAR_EXISTS
         IF !CLAVAR_EXISTS
            BUNDLE.GET SELF, "OBJECT VARIABLES", OBJVAR
            BUNDLE.GET OBJVAR, VAR_NAME$, RESPONSE$
            FN.RTN RESPONSE$
         END IF
      END IF           
   ELSE
      LOG_EVENT$("FAIL", "VARIABLE RETRIEVAL FAILURE: FAILED TO RETRIEVE VARIABLE OF POINTER REFERENCED AT '" + STR$(SELF) + "' AS IT HAS NOT BEEN DEFINED PROPERLY AS AN rfOOP OBJECT OR CLASS")
   END IF

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: VARIABLES
FUNCTION: GET_VARIABLE(SELF, VAR_NAME$)
GET (VAR_NAME$) AS {NUMERIC} TYPE FROM 
OBJECT OR CLASS VARIABLE LIST OF (SELF)
!!


FN.DEF GET_VARIABLE(SELF, VAR_NAME$)

   BUNDLE.KEYS SELF, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$
      IF KEY$ = "CLASS VARIABLES"
         BUNDLE.GET SELF, KEY$, CLASS_VARIABLE_POINTER
         BUNDLE.KEYS CLASS_VARIABLE_POINTER, CLASS_VARIABLES
         LIST.SIZE CLASS_VARIABLES, TOTAL_CLASS_VARIABLES
         FOR CLASS_VARIABLE = 1 TO TOTAL_CLASS_VARIABLES
            LIST.GET CLASS_VARIABLES, CLASS_VARIABLE, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE CLASS_VARIABLE_POINTER, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     FOUND$ = "TRUE"
                     LOG_EVENT$("FAIL", "TYPE MISMATCH VARIABLE '" + VAR_NAME$ + "' IS NOT AN INTEGER")
                  ELSE
                     FOUND$ = "TRUE"
                     BUNDLE.GET CLASS_VARIABLE_POINTER, VARIABLE$, RESPONSE
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS BOTH CLASS AND OBJECT")
               END IF
            END IF
         NEXT CLASS_VARIABLE
      ELSEIF KEY$ = "OBJECT VARIABLES"
         BUNDLE.GET SELF, KEY$, OBJECT_VARIABLE_POINTER
         BUNDLE.KEYS OBJECT_VARIABLE_POINTER, OBJECT_VARIABLES
         LIST.SIZE OBJECT_VARIABLES, TOTAL_OBJECT_VARIABLES
         FOR OBJECT_VARIABLE = 1 TO TOTAL_OBJECT_VARIABLES
            LIST.GET OBJECT_VARIABLES, OBJECT_VARIABLE, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE OBJECT_VARIABLE_POINTER, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     FOUND$ = "TRUE"
                     LOG_EVENT$("FAIL", "TYPE MISMATCH VARIABLE '" + VAR_NAME$ + "' IS NOT AN INTEGER")
                  ELSE
                     FOUND$ = "TRUE"
                     BUNDLE.GET OBJECT_VARIABLE_POINTER, VARIABLE$, RESPONSE
                  END IF 
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS BOTH CLASS AND OBJECT")
               END IF 
            END IF
         NEXT OBJECT_VARIABLE
      END IF
   NEXT KEY

   IF FOUND$ <> "TRUE"
      LOG_EVENT$("FAIL", "NO VARIABLE NAMED '" + VAR_NAME$ + "' FOUND IN OBJECT OR CLASS SPACE")
   ELSE
   LOG_EVENT$("PASS", "RETRIEVED VARIABLE NAMED '" + VAR_NAME$ + "' WITH A VALUE OF '" +  STR$(RESPONSE) + "'")
      FN.RTN RESPONSE
   END IF

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: VARIABLES
FUNCTION: SET_VARIABLE$(SELF, VAR_NAME$, VAR_DATA$)
SET (VAR_NAME$) WITH (VAR_DATA$) AS {STRING} TYPE 
FROM OBJECT OR CLASS VARIABLE LIST OF (SELF)
!!


FN.DEF SET_VARIABLE$(SELF, VAR_NAME$, VAR_DATA$)

   BUNDLE.KEYS SELF, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$
      IF KEY$ = "CLASS VARIABLES"
         BUNDLE.GET SELF, KEY$, CLASS_VARIABLE_POINTER
         BUNDLE.KEYS CLASS_VARIABLE_POINTER, CLASS_VARIABLES
         LIST.SIZE CLASS_VARIABLES, TOTAL_CLASS_VARIABLES
         FOR CLASS_VARIABLE = 1 TO TOTAL_CLASS_VARIABLES
            LIST.GET CLASS_VARIABLES, CLASS_VARIABLE, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE CLASS_VARIABLE_POINTER, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     FOUND$ = "TRUE"
                     BUNDLE.PUT CLASS_VARIABLE_POINTER, VARIABLE$, VAR_DATA$
                  ELSE
                     IF IS_NUMBER(VAR_DATA$) <> 0
                        FOUND$ = "TRUE"
                        BUNDLE.PUT CLASS_VARIABLE_POINTER, VARIABLE$, VAL(VAR_DATA$)
                     ELSE
                        LOG_EVENT$("FAIL", "CAN NOT LOAD A STRING INTO AN INTEGER TYPE UNLESS THE STRING IS ALSO CONVERTABLE")
                     END IF 
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS BOTH CLASS AND OBJECT")
               END IF
            END IF
         NEXT CLASS_VARIABLE
      ELSEIF KEY$ = "OBJECT VARIABLES"
         BUNDLE.GET SELF, KEY$, OBJECT_VARIABLE_POINTER   
         BUNDLE.KEYS OBJECT_VARIABLE_POINTER, OBJECT_VARIABLES
         LIST.SIZE OBJECT_VARIABLES, TOTAL_OBJECT_VARIABLES
         FOR OBJECT_VARIABLE = 1 TO TOTAL_OBJECT_VARIABLES
            LIST.GET OBJECT_VARIABLES, OBJECT_VARIABLE, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE OBJECT_VARIABLE_POINTER, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                    FOUND$ = "TRUE"
                    BUNDLE.PUT OBJECT_VARIABLE_POINTER, VARIABLE$, VAR_DATA$
                  ELSE
                     IF IS_NUMBER(VAR_DATA$) <> 0
                        FOUND$ = "TRUE"
                        BUNDLE.PUT OBJECT_VARIABLE_POINTER, VARIABLE$, VAL(VAR_DATA$)
                     ELSE
                        LOG_EVENT$("FAIL", "CAN NOT LOAD A STRING INTO AN INTEGER TYPE UNLESS THE STRING IS ALSO AN INTEGER")
                     END IF
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS BOTH CLASS AND OBJECT")
               END IF 
            END IF
         NEXT OBJECT_VARIABLE
      END IF
   NEXT KEY
   
   IF FOUND$ <> "TRUE"
      LOG_EVENT$("FAIL", "NO VARIABLE NAMED '" + VAR_NAME$ + "' FOUND IN OBJECT OR CLASS SPACE")
   ELSE
      LOG_EVENT$("PASS", "VARIABLE NAMED '" + VAR_NAME$ + "' SET TO '" +  VAR_DATA$ + "'")
   END IF

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: VARIABLES
FUNCTION: SET_VARIABLE(SELF, VAR_NAME$, VAR_DATA)
SET (VAR_NAME$) WITH (VAR_DATA) AS {NUMERIC} TYPE 
FROM OBJECT OR CLASS VARIABLE LIST OF (SELF)
!!


FN.DEF SET_VARIABLE(SELF, VAR_NAME$, VAR_DATA)

   BUNDLE.KEYS SELF, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$
      IF KEY$ = "CLASS VARIABLES"
         BUNDLE.GET SELF, KEY$, CLASS_VARIABLE_POINTER
         BUNDLE.KEYS CLASS_VARIABLE_POINTER, CLASS_VARIABLES
         LIST.SIZE CLASS_VARIABLES, TOTAL_CLASS_VARIABLES
         FOR CLASS_VARIABLE = 1 TO TOTAL_CLASS_VARIABLES
            LIST.GET CLASS_VARIABLES, CLASS_VARIABLE, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE CLASS_VARIABLE_POINTER, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     FOUND$ = "TRUE"
                     BUNDLE.PUT CLASS_VARIABLE_POINTER, VARIABLE$, STR$(VAR_DATA)
                     LOG_EVENT$("FAIL", "TYPE MISMATCH VARIABLE '" + VAR_NAME$ + "' IS NOT AN INTEGER")
                  ELSE
                     FOUND$ = "TRUE"
                     BUNDLE.PUT CLASS_VARIABLE_POINTER, VARIABLE$, VAR_DATA
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS BOTH CLASS AND OBJECT")
               END IF
            END IF
         NEXT CLASS_VARIABLE
      ELSEIF KEY$ = "OBJECT VARIABLES"
         BUNDLE.GET SELF, KEY$, OBJECT_VARIABLE_POINTER   
         BUNDLE.KEYS OBJECT_VARIABLE_POINTER, OBJECT_VARIABLES
         LIST.SIZE OBJECT_VARIABLES, TOTAL_OBJECT_VARIABLES
         FOR OBJECT_VARIABLE = 1 TO TOTAL_OBJECT_VARIABLES
            LIST.GET OBJECT_VARIABLES, OBJECT_VARIABLE, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE OBJECT_VARIABLE_POINTER, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                    FOUND$ = "TRUE"
                    BUNDLE.PUT OBJECT_VARIABLE_POINTER, VARIABLE$, STR$(VAR_DATA)
                  ELSE
                     FOUND$ = "TRUE"
                     BUNDLE.PUT OBJECT_VARIABLE_POINTER, VARIABLE$, VAR_DATA
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS BOTH CLASS AND OBJECT")
               END IF 
            END IF
         NEXT OBJECT_VARIABLE
      END IF
   NEXT KEY

   IF FOUND$ <> "TRUE"
      LOG_EVENT$("FAIL", "NO VARIABLE NAMED: '" + VAR_NAME$ + "' FOUND IN OBJECT OR CLASS SPACE")
   ELSE
      LOG_EVENT$("PASS", "VARIABLE NAMED '" + VAR_NAME$ + "' SET TO '" + STR$(VAR_DATA) + "'")
   END IF

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: VARIABLES
FUNCTION: ADD_VARIABLE$(SELF, VAR_NAME$, VAR_TYPE$)
ADD A NEW VARIABLE AS (VAR_NAME$) 
OF TYPE (VAR_TYPE$) "S" OR "N" 
!!


FN.DEF ADD_VARIABLE$(SELF, VAR_NAME$, VAR_TYPE$)

   BUNDLE.KEYS SELF, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR TYPE = 1 TO TOTAL_KEYS
      LIST.GET KEYS, TYPE, KEY$
      IF KEY$ = "TYPE"
         BUNDLE.GET SELF, KEY$, TYPE$
      END IF
   NEXT TYPE


   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$      
      IF IS_IN("CLASS", TYPE$) 
         IF KEY$ = "CLASS VARIABLES"
            BUNDLE.KEYS KEY, CLASS_VARIABLES
            LIST.SIZE CLASS_VARIABLES, TOTAL_CLASS_VARIABLES
            FOR CLASS_VARIABLE = 1 TO TOTAL_CLASS_VARIABLES
               LIST.GET CLASS_VARIABLES, CLASS_VARIABLE, VARIABLE$
               IF VARIABLE$ = VAR_NAME$
                  LOG_EVENT$("FAIL", "THIS VARIABLE HAS ALREADY BEEN ADDED TO THE CLASS SPACE")
               END IF
            NEXT CLASS_VARIABLE
      ELSEIF IS_IN("OBJECT", TYPE$)
         ELSEIF KEY$ = "OBJECT VARIABLES"
            BUNDLE.KEYS KEY, OBJECT_VARIABLES
            LIST.SIZE OBJECT_VARIABLES, TOTAL_OBJECT_VARIABLES
            FOR OBJECT_VARIABLE = 1 TO TOTAL_OBJECT_VARIABLES
               LIST.GET OBJECT_VARIABLES, OBJECT_VARIABLE, VARIABLE$
               IF VARIABLE$ = VAR_NAME$
                  LOG_EVENT$("FAIL", "THIS VARIABLE HAS ALREADY BEEN ADDED TO THE OBJECT SPACE")
               END IF
            NEXT OBJECT_VARIABLE
         END IF
      END IF 
   NEXT KEY

   IF VAR_TYPE$ = "S"
      ALLOWED$ = "TRUE"
   ELSEIF VAR_TYPE$ = "N"
      ALLOWED$ = "TRUE"
   END IF 

   IF ALLOWED$ = "TRUE"
      IF TYPE$ = "CLASS"
         BUNDLE.GET SELF, "CLASS VARIABLES", CLASS_VARIABLE_POINTER
         IF VAR_TYPE$ = "S"
            BUNDLE.PUT CLASS_VARIABLE_POINTER, VAR_NAME$, "DEFAULT VALUE"
         ELSEIF VAR_TYPE$ = "N"
            BUNDLE.PUT CLASS_VARIABLE_POINTER, VAR_NAME$, DEFAULT_VALUE
         END IF
         LOG_EVENT$("PASS", "SUCCESSFULLY ADDED VARIABLE '" + VAR_NAME$ + "' AS CLASS VARIABLE")
      ELSEIF TYPE$ = "OBJECT"
         BUNDLE.GET SELF, "OBJECT VARIABLES", OBJECT_VARIABLE_POINTER
         IF VAR_TYPE$ = "S"
            BUNDLE.PUT OBJECT_VARIABLE_POINTER, VAR_NAME$, "DEFAULT VALUE"
         ELSEIF VAR_TYPE$ = "N"
            BUNDLE.PUT OBJECT_VARIABLE_POINTER, VAR_NAME$, DEFAULT_VALUE
         END IF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   LOG_EVENT$("PASS", "SUCCESSFULLY ADDED VARIABLE '" + VAR_NAME$ + "' AS OBJECT VARIABLE")
      ELSE
         LOG_EVENT$("FAIL", "ONLY CLASS AND OBJECT VARIABLES ARE SUPPORTED AT THIS TIME")
      END IF
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: VARIABLES
FUNCTION: VARIABLE_EXISTS(SELF, VAR_NAME$)
CHECKS (SELF) TO SEE IF (VAR_NAME$) EXISTS
THEN RETURNS 0 FOR FALSE OR 1 FOR TRUE
!!


FN.DEF VARIABLE_EXISTS(SELF, VAR_NAME$)

   TRUE = 1
   FALSE = 0

   BUNDLE.GET SELF, "CLASS VARIABLES", CLASS_VARIABLES
   BUNDLE.GET SELF, "OBJECT VARIABLES", OBJECT_VARIABLES
   BUNDLE.KEYS CLASS_VARIABLES, CLASS_KEYS 
   BUNDLE.KEYS OBJECT_VARIABLES, OBJECT_KEYS
   LIST.SEARCH CLASS_KEYS, VAR_NAME$, CLASS_VARIABLE_EXISTS
   LIST.SEARCH OBJECT_KEYS, VAR_NAME$, OBJECT_VARIABLE_EXISTS
      
   IF CLASS_VARIABLE_EXISTS
      FN.RTN TRUE
   ELSE IF OBJECT_VARIABLE_EXISTS
      FN.RTN TRUE
   ELSE
      FN.RTN FALSE
   END IF

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: VARIABLES
FUNCTION: VARIABLE_EXISTS(SELF, VAR_NAME$)
CHECKS (SELF) TO SEE IF (VAR_NAME$) EXISTS
THEN RETURNS EITHER "TRUE" OR "FALSE"
!!


FN.DEF VARIABLE_EXISTS$(SELF, VAR_NAME$)

   BUNDLE.GET SELF, "CLASS VARIABLES", CLASS_VARIABLES
   BUNDLE.GET SELF, "OBJECT VARIABLES", OBJECT_VARIABLES
   BUNDLE.KEYS CLASS_VARIABLES, CLASS_KEYS 
   BUNDLE.KEYS OBJECT_VARIABLES, OBJECT_KEYS
   LIST.SEARCH CLASS_KEYS, VAR_NAME$, CLASS_VARIABLE_EXISTS
   LIST.SEARCH OBJECT_KEYS, VAR_NAME$, OBJECT_VARIABLE_EXISTS
      
   IF CLASS_VARIABLE_EXISTS
      FN.RTN "TRUE"
   ELSE IF OBJECT_VARIABLE_EXISTS
      FN.RTN "TRUE"
   ELSE
      FN.RTN "FALSE"
   END IF

FN.END



!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: PROPERTIES
FUNCTION: PROPERTY_TYPE$(SELF, PROPERTY$)
GET THE TYPE OF PROPERTY DEFINED AS (PROPERTY$)
FROM AN rfOOP OBJECT OR A rfOOP CLASS (SELF)
!!


FN.DEF PROPERTY_TYPE$(SELF, PROPERTY$)

   BUNDLE.KEYS SELF, KEYS

   LIST.SEARCH KEYS, PROPERTY$, EXISTS

   IF EXISTS <> 0     
      BUNDLE.TYPE SELF, PROPERTY$, TYPE$               
      IF TYPE$ = "S"
         LOG_EVENT$("PASS", "SUCCESSFULLY RETRIEVED TYPE '" + TYPE$ + "' OF PROPERTY DEFINED AS '" + PROPERTY$ + "' FROM '" + GET_NAME$(SELF) + "'")
      ELSE IF TYPE$ = "N"
         LOG_EVENT$("PASS", "SUCCESSFULLY RETRIEVED TYPE '" + TYPE$ + "' OF PROPERTY DEFINED AS '" + PROPERTY$ + "' FROM '" + GET_NAME$(SELF) + "'")
      END IF
   ELSE
      LOG_EVENT$("FAIL", "THE PROPERTY DEFINED AS '" + PROPERTY$ + "' FROM '" + GET_NAME$(SELF) + "' DOES NOT EXIST")
   END IF

FN.RTN TYPE$

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: PROPERTIES
FUNCTION: GET_PROPERTIES(SELF)
GET A LIST OF PROPERTIES
ASSOCIATED WITH (SELF)
!!


FN.DEF GET_PROPERTIES(SELF)

   BUNDLE.KEYS SELF, PROPERTIES
   
   LIST.SIZE PROPERTIES, TOTAL_PROPERTIES

   IF TOTAL_PROPERTIES > 1
      LOG_EVENT$("PASS", "SUCCESSFULLY RETRIEVED PROPERTIES OF '" + GET_NAME$(SELF) + "'")
      FN.RTN PROPERTIES
   ELSE
      LOG_EVENT$("FAIL", "OBJECT OR CLASS DOES NOT EXIST, NO PROPERTIES TO GET")
   END IF

PRINT "DONE GET PROPERTIES"

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: PROPERTIES
FUNCTION: ALLOW_PRIVATE(CLASS)
THIS FUNCTION WILL ALLOW (CLASS) TO HAVE USER DEFINED 
PRIVATE PROPERTIES OUTSIDE OF THE SYSTEM DEFINED ONES
!!


FN.DEF ALLOW_PRIVATE(CLASS)

   IF VARIABLE_EXISTS$(CLASS, "PRIVATE_PROPERTIES") = "FALSE"
      LIST.CREATE S, PRIVATE_PROPERTIES
      ADD_VARIABLE$(CLASS, "PRIVATE_PROPERTIES", "N")
   END IF 
   SET_VARIABLE(CLASS, "PRIVATE_PROPERTIES", PRIVATE_PROPERTIES)
   
FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: PROPERTIES
FUNCTION: MAKE_PRIVATE$(CLASS, PROPERTY$)
USE AFTER ALLOWING PRIVATE PROPERTIES
TO MAKE (PROPERTY$) OF (CLASS) PRIVATE
!!


FN.DEF MAKE_PRIVATE$(CLASS, PROPERTY$)

   PROPERTIES = GET_PROPERTIES(CLASS)
   LIST.SEARCH PROPERTIES, PROPERTY$, PROPERTY_EXISTS

   IF PROPERTY_EXISTS
   
      PRIVATE_PROPERTIES = GET_VARIABLE(CLASS, "PRIVATE_PROPERTIES")
      LIST.SEARCH PRIVATE_PROPERTIES, PROPERTY$, EXISTS
      PRINT "EXISTS" + STR$(EXISTS)
      
      IF !EXISTS 
   
         LIST.ADD PRIVATE_PROPERTIES, PROPERTY$
      
      END IF 
      
      LIST.SIZE PRIVATE_PROPERTIES, SIZE
      PRINT "SIZE IS " + STR$(SIZE)
      SET_VARIABLE(CLASS, "PRIVATE_PROPERTIES", PRIVATE_PROPERTIES)
      
   ELSE
   
   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: PROPERTIES
FUNCTION: PUBLIC_PROPERTIES(CLASS)
THIS FUNCTION RETURNS A LIST 
OF THE PROPERTIES OF (CLASS)
!!


FN.DEF PUBLIC_PROPERTIES(CLASS)

   PROPERTIES = GET_PROPERTIES(CLASS)

   LIST.SEARCH PROPERTIES, "NAME", NAME
   LIST.REMOVE PROPERTIES, NAME
   LIST.SEARCH PROPERTIES, "TYPE", TYPE
   LIST.REMOVE PROPERTIES, TYPE
   LIST.SEARCH PROPERTIES, "SUB TYPE", SUB_TYPE
   LIST.REMOVE PROPERTIES, SUB_TYPE
   LIST.SEARCH PROPERTIES, "TYPINGS", TYPINGS
   LIST.REMOVE PROPERTIES, TYPINGS
   LIST.SEARCH PROPERTIES, "INDEX", INDEX
   LIST.REMOVE PROPERTIES, INDEX
   LIST.SEARCH PROPERTIES, "CLASS VARIABLES", CLASS_VARIABLES
   LIST.REMOVE PROPERTIES, CLASS_VARIABLES
   LIST.SEARCH PROPERTIES, "OBJECT VARIABLES", OBJECT_VARIABLES
   LIST.REMOVE PROPERTIES, OBJECT_VARIABLES
   
   IF VARIABLE_EXISTS$(CLASS, "PRIVATE_PROPERTIES") <> "FALSE"
   
      USER_PROPERTIES = GET_VARIABLE(CLASS, "PRIVATE_PROPERTIES")
      LIST.SIZE USER_PROPERTIES, TOTAL_PROPERTIES
      
      FOR PROPERTY = 1 TO TOTAL_PROPERTIES
      
         LIST.GET USER_PROPERTIES, PROPERTY, PROPERTY$
         LIST.SEARCH PROPERTIES, PROPERTY$, INDEX
         LIST.REMOVE PROPERTIES, INDEX 
      
      NEXT PROPERTY
      
   END IF

   FN.RTN PROPERTIES

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: PROPERTIES
FUNCTION: PROPERTY_EXISTS$(CLASS, PROPERTY$)
CHECKS IF (PROPERTY$) OF (CLASS)
EXISTS RETURNS "TRUE" OR "FALSE"
!!


FN.DEF PROPERTY_EXISTS$(CLASS, PROPERTY$)

   PROPERTIES = GET_PROPERTIES(CLASS)

   LIST.SEARCH PROPERTIES, PROPERTY$, EXISTS

   IF !EXISTS

      FN.RTN "TRUE"
   
   ELSE

      FN.RTN "FALSE"

   END IF 

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: PROPERTIES
FUNCTION: PROPERTY_EXISTS(CLASS, PROPERTY$)
CHECKS IF (PROPERTY$) OF (CLASS) EXISTS 
THEN RETURN 0 IF "FALSE" OR 1 IF "TRUE"
!!


FN.DEF PROPERTY_EXISTS(CLASS, PROPERTY$)

   PROPERTIES = GET_PROPERTIES(CLASS)

   LIST.SEARCH PROPERTIES, PROPERTY$, EXISTS

   IF !EXISTS

      FN.RTN 1
   
   ELSE

      FN.RTN 0

   END IF 

FN.END


! -------------------------------------------------------------------------------
!GET A GLOBAL VARIABLE AS A STRING TYPE


FN.DEF GET_GLOBAL$(VAR_NAME$)

   BUNDLE.KEYS 1, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$
      IF KEY$ = "rfOOP"
         BUNDLE.GET 1, KEY$, rfOOP
         BUNDLE.GET rfOOP, "GLOBALS", GLOBALS
         BUNDLE.KEYS GLOBALS, rfOOP_KEYS
         LIST.SIZE rfOOP_KEYS, TOTAL_rfOOP_KEYS
         FOR rfOOP_KEY = 1 TO TOTAL_rfOOP_KEYS
            LIST.GET rfOOP_KEYS, rfOOP_KEY, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE GLOBALS, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     FOUND$ = "TRUE"
                     BUNDLE.GET GLOBALS, VARIABLE$, RESPONSE$
                  ELSE
                     FOUND$ = "TRUE"
                     BUNDLE.GET GLOBALS, VARIABLE$, RESPONSE
                     RESPONSE$ = STR$(RESPONSE)
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
               END IF
            END IF
         NEXT rfOOP_KEY
      END IF 
   NEXT KEY
   
   IF FOUND$ <> "TRUE"
      LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' NOT FOUND IN GLOBAL VARIABLE NAMESPACE")
   ELSE
      LOG_EVENT$("PASS",  "RETRIEVED VARIABLE NAMED '" + VAR_NAME$ + "' WITH A VALUE OF '" + RESPONSE$ + "'")
      FN.RTN RESPONSE$
   END IF

FN.END


! -------------------------------------------------------------------------------
!GET A GLOBAL VARIABLE AS A STRING TYPE


FN.DEF GET_GLOBAL(VAR_NAME$)

   BUNDLE.KEYS 1, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$
      IF KEY$ = "rfOOP"
         BUNDLE.GET 1, KEY$, rfOOP
         BUNDLE.GET rfOOP, "GLOBALS", GLOBALS
         BUNDLE.KEYS GLOBALS, rfOOP_KEYS
         LIST.SIZE rfOOP_KEYS, TOTAL_rfOOP_KEYS
         FOR rfOOP_KEY = 1 TO TOTAL_rfOOP_KEYS
            LIST.GET rfOOP_KEYS, rfOOP_KEY, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE GLOBALS, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     LOG_EVENT$("FAIL", "TYPE MISMATCH: VARIABLE NAMED '" + VAR_NAME$ + "' IS OF STRING TYPE")
                  ELSE
                     FOUND$ = "TRUE"
                     BUNDLE.GET GLOBALS, VARIABLE$, RESPONSE
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
               END IF
            END IF
         NEXT rfOOP_KEY
      END IF 
   NEXT KEY
   
   IF FOUND$ <> "TRUE"
      LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' NOT FOUND IN GLOBAL VARIABLE NAMESPACE")
   ELSE
      LOG_EVENT$("PASS",  "RETRIEVED VARIABLE NAMED '" + VAR_NAME$ + "' WITH A VALUE OF '" + RESPONSE$ + "'")
      FN.RTN RESPONSE
   END IF

FN.END


! -------------------------------------------------------------------------------
!SET GLOBAL VARIABLE DEFINED AS A STRING


FN.DEF SET_GLOBAL$(VAR_NAME$, VAR_DATA$)

   BUNDLE.KEYS 1, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$
      IF KEY$ = "rfOOP"
         BUNDLE.GET 1, KEY$, rfOOP
         BUNDLE.GET rfOOP, "GLOBALS", GLOBALS
         BUNDLE.KEYS GLOBALS, rfOOP_KEYS
         LIST.SIZE rfOOP_KEYS, TOTAL_rfOOP_KEYS
         FOR rfOOP_KEY = 1 TO TOTAL_rfOOP_KEYS
            LIST.GET rfOOP_KEYS, rfOOP_KEY, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE GLOBALS, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     FOUND$ = "TRUE"
                     BUNDLE.PUT GLOBALS, VARIABLE$, VAR_DATA$
                  ELSE
                     FOUND$ = "TRUE"
                     BUNDLE.PUT GLOBALS, VARIABLE$, VAL(VAR_DATA$)
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
               END IF
            END IF
         NEXT rfOOP_KEY
      END IF 
   NEXT KEY

   IF FOUND$ <> "TRUE"
      LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' NOT FOUND IN GLOBAL VARIABLE NAMESPACE")
   ELSE
      LOG_EVENT$("PASS",  "VARIABLE NAMED '" + VAR_NAME$ + "' SET WITH A VALUE OF '" + VAR_DATA$ + "'")
   END IF

FN.END


! -------------------------------------------------------------------------------
!SET GLOBAL VARIABLE DEFINED AS A STRING


FN.DEF SET_GLOBAL(VAR_NAME$, VAR_DATA)

   BUNDLE.KEYS 1, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$
      IF KEY$ = "rfOOP"
         BUNDLE.GET 1, KEY$, rfOOP
         BUNDLE.GET rfOOP, "GLOBALS", GLOBALS
         BUNDLE.KEYS GLOBALS, rfOOP_KEYS
         LIST.SIZE rfOOP_KEYS, TOTAL_rfOOP_KEYS
         FOR rfOOP_KEY = 1 TO TOTAL_rfOOP_KEYS
            LIST.GET rfOOP_KEYS, rfOOP_KEY, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE GLOBALS, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     LOG_EVENT$("FAIL", "TYPE MISMATCH: VARIABLE NAMED '" + VAR_NAME$ + "' IS OF STRING TYPE")
                  ELSE
                     FOUND$ = "TRUE"
                     BUNDLE.PUT GLOBALS, VARIABLE$, VAR_DATA
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
               END IF
            END IF
         NEXT rfOOP_KEY
      END IF 
   NEXT KEY

   IF FOUND$ <> "TRUE"
      LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' NOT FOUND IN GLOBAL VARIABLE NAMESPACE")
   ELSE
      LOG_EVENT$("PASS",  "VARIABLE NAMED '" + VAR_NAME$ + "' SET WITH A VALUE OF '" + STR$(VAR_DATA) + "'")
   END IF

FN.END




! -------------------------------------------------------------------------------
!ADD A GLOBAL VARIABLE AS TYPE STRING


FN.DEF ADD_GLOBAL(VAR_NAME$, VAR_DATA, VAR_TYPE$)

   BUNDLE.KEYS 1, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$
      IF KEY$ = "rfOOP"
         BUNDLE.GET 1, KEY$, rfOOP
         BUNDLE.GET rfOOP, "GLOBALS", GLOBALS
         BUNDLE.KEYS GLOBALS, rfOOP_KEYS
         LIST.SIZE rfOOP_KEYS, TOTAL_rfOOP_KEYS
         FOR rfOOP_KEY = 1 TO TOTAL_rfOOP_KEYS
            LIST.GET rfOOP_KEYS, rfOOP_KEY, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE rfOOP_KEY, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     FOUND$ = "TRUE"
                     LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
                  ELSE
                     FOUND$ = "TRUE"
                     LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
               END IF
            END IF
         NEXT rfOOP_KEY
      END IF 
   NEXT KEY

   IF FOUND$ <> "TRUE"
      IF VAR_TYPE$ = "S"
         LOG_EVENT$("FAIL", "TYPE MISMATCH: VARIABLE NAMED '" + VAR_NAME$ + "' IS OF STRING TYPE")
      ELSEIF VAR_TYPE$ = "N"
         BUNDLE.PUT GLOBALS, VAR_NAME$, VAR_DATA
         LOG_EVENT$("PASS",  "ADDED VARIABLE NAMED '" + VAR_NAME$ + "' WITH A VALUE OF '" + STR$(VAR_DATA) + "'")
      ELSE
         LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' MUST BE DEFINED AS NUMERIC OR STRING TYPE")
      END IF
   ELSE
      LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' NOT FOUND IN GLOBAL VARIABLE NAMESPACE")
   END IF

FN.END


! -------------------------------------------------------------------------------
!ADD A GLOBAL VARIABLE AS TYPE STRING


FN.DEF ADD_GLOBAL$(VAR_NAME$, VAR_DATA$, VAR_TYPE$)

   BUNDLE.KEYS 1, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$
      IF KEY$ = "rfOOP"
         BUNDLE.GET 1, KEY$, rfOOP
         BUNDLE.GET rfOOP, "GLOBALS", GLOBALS
         BUNDLE.KEYS GLOBALS, rfOOP_KEYS
         LIST.SIZE rfOOP_KEYS, TOTAL_rfOOP_KEYS
         FOR rfOOP_KEY = 1 TO TOTAL_rfOOP_KEYS
            LIST.GET rfOOP_KEYS, rfOOP_KEY, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE rfOOP_KEY, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     FOUND$ = "TRUE"
                     LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
                  ELSE
                     FOUND$ = "TRUE"
                     LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
               END IF
            END IF
         NEXT rfOOP_KEY
      END IF 
   NEXT KEY

   IF FOUND$ <> "TRUE"
      IF VAR_TYPE$ = "S"
         BUNDLE.PUT GLOBALS, VAR_NAME$, VAR_DATA$
         LOG_EVENT$("PASS",  "ADDED VARIABLE NAMED '" + VAR_NAME$ + "' WITH A VALUE OF '" + VAR_DATA$ + "' AS TYPE '" + VAR_TYPE$ + "'")
      ELSEIF VAR_TYPE$ = "N"
         LOG_EVENT$("FAIL", "TYPE MISMATCH: VARIABLE NAMED '" + VAR_NAME$ + "' IS OF STRING TYPE")
      ELSE
         LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' MUST BE DEFINED AS NUMERIC OR STRING TYPE")
      END IF
   ELSE
      LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' NOT FOUND IN GLOBAL VARIABLE NAMESPACE")
   END IF

FN.END


! -------------------------------------------------------------------------------
!ADD A GLOBAL VARIABLE AS TYPE STRING


FN.DEF GLOBAL$(VAR_NAME$, VAR_DATA$)

   BUNDLE.KEYS 1, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$
      IF KEY$ = "rfOOP"
         BUNDLE.GET 1, KEY$, rfOOP
         BUNDLE.GET rfOOP, "GLOBALS", GLOBALS
         BUNDLE.KEYS GLOBALS, rfOOP_KEYS
         LIST.SIZE rfOOP_KEYS, TOTAL_rfOOP_KEYS
         FOR rfOOP_KEY = 1 TO TOTAL_rfOOP_KEYS
            LIST.GET rfOOP_KEYS, rfOOP_KEY, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE rfOOP_KEY, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     FOUND$ = "TRUE"
                     LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
                  ELSE
                     FOUND$ = "TRUE"
                     LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
               END IF
            END IF
         NEXT rfOOP_KEY
      END IF 
   NEXT KEY

   IF FOUND$ <> "TRUE"
      BUNDLE.PUT GLOBALS, VAR_NAME$, VAR_DATA$
      LOG_EVENT$("PASS",  "ADDED VARIABLE NAMED '" + VAR_NAME$ + "' WITH A VALUE OF '" + VAR_DATA$ + "' AS TYPE '" + VAR_TYPE$ + "'")
   ELSE
      LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' NOT FOUND IN GLOBAL VARIABLE NAMESPACE")
   END IF

FN.END


! -------------------------------------------------------------------------------
!ADD A GLOBAL VARIABLE AS TYPE STRING


FN.DEF GLOBAL(VAR_NAME$, VAR_DATA)

   BUNDLE.KEYS 1, KEYS

   LIST.SIZE KEYS, TOTAL_KEYS

   FOR KEY = 1 TO TOTAL_KEYS
      LIST.GET KEYS, KEY, KEY$
      IF KEY$ = "rfOOP"
         BUNDLE.GET 1, KEY$, rfOOP
         BUNDLE.GET rfOOP, "GLOBALS", GLOBALS
         BUNDLE.KEYS GLOBALS, rfOOP_KEYS
         LIST.SIZE rfOOP_KEYS, TOTAL_rfOOP_KEYS
         FOR rfOOP_KEY = 1 TO TOTAL_rfOOP_KEYS
            LIST.GET rfOOP_KEYS, rfOOP_KEY, VARIABLE$
            IF VARIABLE$ = VAR_NAME$
               IF FOUND$ <> "TRUE"
                  BUNDLE.TYPE rfOOP_KEY, VARIABLE$, TYPE$
                  IF TYPE$ = "S"
                     FOUND$ = "TRUE"
                     LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
                  ELSE
                     FOUND$ = "TRUE"
                     LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
                  END IF
               ELSE
                  LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' HAS BEEN DEFINED MORE THAN ONCE AS A GLOBAL VARIABLE")
               END IF
            END IF
         NEXT rfOOP_KEY
      END IF 
   NEXT KEY

   IF FOUND$ <> "TRUE"
      BUNDLE.PUT GLOBALS, VAR_NAME$, VAR_DATA
      LOG_EVENT$("PASS",  "ADDED VARIABLE NAMED '" + VAR_NAME$ + "' WITH A VALUE OF '" + STR$(VAR_DATA) + "' AS TYPE '" + VAR_TYPE$ + "'")
   ELSE
      LOG_EVENT$("FAIL", "VARIABLE NAMED '" + VAR_NAME$ + "' NOT FOUND IN GLOBAL VARIABLE NAMESPACE")
   END IF

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: GLOBALS
FUNCTION: GLOBAL_EXISTS$(VAR_NAME$)
CHECKS (GLOBALS) TO SEE IF (VAR_NAME$) EXISTS
THEN RETURNS EITHER "TRUE" OR "FALSE"
!!


FN.DEF GLOBAL_EXISTS$(VAR_NAME$)

   BUNDLE.GET 1, "rfOOP", rfOOP
   BUNDLE.GET rfOOP, "GLOBALS", GLOBALS
   BUNDLE.KEYS GLOBALS, GLOBAL_KEYS
   LIST.SEARCH GLOBAL_KEYS, VAR_NAME$, GLOBAL_VARIABLE_EXISTS
      
   IF GLOBAL_VARIABLE_EXISTS
      FN.RTN "TRUE"
   ELSE
      FN.RTN "FALSE"
   END IF

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: GLOBALS
FUNCTION: GLOBAL_EXISTS(VAR_NAME$)
CHECKS (GLOBALS) TO SEE IF (VAR_NAME$) EXISTS
THEN RETURNS 0 FOR "FALSE" AND 1 FOR "TRUE"
!!


FN.DEF GLOBAL_EXISTS(VAR_NAME$)

   TRUE = 1
   FALSE = 0

   BUNDLE.GET 1, "rfOOP", rfOOP
   BUNDLE.GET rfOOP, "GLOBALS", GLOBALS
   BUNDLE.KEYS GLOBALS, GLOBAL_KEYS
   LIST.SEARCH GLOBAL_KEYS, VAR_NAME$, GLOBAL_VARIABLE_EXISTS
      
   IF GLOBAL_VARIABLE_EXISTS
      FN.RTN TRUE
   ELSE
      FN.RTN FALSE
   END IF

FN.END


!>-------------------------------------------------------------------------------
!!
VER: 0.1
LIB: GLOBALS
FUNCTION: GLOBALS()
CHECKS (GLOBALS) TO SEE IF (VAR_NAME$) EXISTS
THEN RETURNS 0 FOR "FALSE" AND 1 FOR "TRUE"
!!


FN.DEF GLOBALS()

FALSE = 8

   BUNDLE.GET 1, "rfOOP", rfOOP
   BUNDLE.GET rfOOP, "GLOBALS", GLOBALS
   BUNDLE.KEYS GLOBALS, GLOBAL_KEYS
   LIST.SIZE GLOBAL_KEYS, GLOBAL_VARIABLES
      
   IF GLOBAL_VARIABLE_EXISTS
      FN.RTN GLOBAL_KEYS
   ELSE
      FN.RTN FALSE
   END IF

FN.END